#ifndef PLAYER_H
#define PLAYER_H

#include <stdlib.h>
#include <stdio.h>
#include "card.h"
#include "deck.h"
#include <stdbool.h>
#include <string.h>
/*
 * Structure: player
 * -----------------
 *  Each player holds some number of cards in their hand
 *  Each player can have at most 7 "books" before winning 
 */
struct player {
  struct hand* card_list;
  char book[7];
  size_t hand_size;
  size_t book_size;// created to increment
};

/* jifeowef
 * Instance Variables: user, computer
 * ----------------------------------
 *
 *  We only support 2 users: a human and a computer
 */
struct player user;
struct player computer;
//  imagine 7 hands, each hand has a different card  each hand is a node with 1 card, and that hand points to the next 
/*
 * Function: add_card
 * -------------------
 *  Add a new card to the player's hand. 
 *
 *  target: the target player
 *  new_card: pointer to the new card to add
 *
 *  returns: return 0 if no error, non-zero otherwise
 */

//2 different ways of printing the card 
//printf("answer: %c%c%c \n ",(*new_card).suit ,(*new_card).rank[0],(*new_card).rank[1]   );
//printf("card added: %c%c%c \n ",  new_card->suit ,  new_card->rank[0],new_card->rank[1]   );

int  add_card(struct player* target, struct card* new_card){
//create node new_card and add this node to the end of the players deck which is a linked list of nodes

if (target == NULL || new_card==NULL)
{				//fail case
printf("unable to allocate memory for target \n");
	return -1;
}

// card list is pointer to head of linked list
// looking at specific players deck

//(pointer name)-->(variable name)

struct hand* new_item=NULL; //used to create the node of the card being added
new_item  = (struct hand*)malloc(sizeof(struct hand));
if (new_item == NULL)
{				//fail case
printf("unable to allocate memory for new_item \n");
	return -1;
}
//creates new_item node BASED ON HAND, WHICH HAS TOP AND NEXT
new_item->top = *new_card;// sets the argument new card to a node
new_item->next= NULL; // will be last element

struct hand* head=target->card_list;
// or can do struct hand* head=target->card_list
//if initial node does is null set it to the null item
if(target->card_list == NULL){
        target->card_list = new_item;
}
else{	
        //head = target->card_list;
		//traverse the list and set the current head to the next 
        while(head->next != NULL){
                head = head->next;    
	  }  //since traversed, set the next to the node
        head->next = new_item;
	}
target->hand_size = target->hand_size+1;// increment hand size
// may need to take out deck_instance.top since you can add card to other hands
//return head;
return 0; // no error
}

/*

 * Function: remove_card
 * ---------------------
 *  Remove a card from the player's hand. 
 *
 *  target: the target player
 *  old_card: pointer to the old card to remove
 *
 *  returns: return 0 if no error, non-zero otherwise
 */

int remove_card(struct player* target, struct card* old_card){
//make structs
struct hand* head = target->card_list;
struct hand* prev = NULL; 

//char reset = target->card_list;    
printf("this is the card we want to remove: %s\n", old_card);

//base case: One of inputs is null, code error
if (head == NULL){printf("base case");return -1;}

//First case: Node to be deleted is head node , 
if(strcmp(old_card,head)==0 && prev==NULL){
	printf("before %s\n", head);
	head = head->next;
	printf("after %s\n", head);

}
//Second Case: Node to be deleted is last node
if(head->next==NULL && head->next==NULL){
	head = prev;
}

if(prev!==NULL && head->next != NULL && strcmp(head,old_card)==0){
	head=prev->next;
	prev->next=head->next;
}
	target->card_list = target->card_list->next;


/*
 
//Third case: any middle node
if (remove != head && remove->next != NULL){
	printf("third case");
	while (target->card_list != NULL){	//traverse through card_list
//if target->card_list->next is the card you want to remove, then set "->next"   card to be the "->next->next" This will skip over the old_card in LL
	if(target->card_list->next == remove){	
		target->card_list->next = target->card_list->next->next;
  	}
	 target->card_list = target->card_list->next; //traverse iteration
 	}
}

//reset pointer
target->card_list=reset;
*/
//free memory
free(head);
return;

}



/*
 * Function: check_add_book
 * ------------------------
 *  Check if a player has all 4 cards of the same rank.
 *  If so, remove those cards from the hand, and add the rank to the book.
 *  Returns after finding one matching set of 4, so should be called after adding each a new card.
 * 
 *  target: pointer to the player to check
 *  
 *  Return: a char that indicates the book that was added; return 0 if no book added.
 */

/*
char check_add_book(struct player* target){
	//10 is not included, seperate case
	char R[12]={'A','2','3','4','5','6','7','8','9','J','Q','K'};

	char counter = 0;

for (int i=0;i<12;i++){		//iterate every case except 10
	while (target->card_list != NULL){
		//need to make a string of the card ur checking without the suit
//the card being checked in the hand changes so the check changes too		
		card_string=target->card_list->top;	//S9-->9 removes suit
		char check=card_string->rank[0]

		//S9 --> 9 =='9' then counter = counter+1
	if (check == R[i]){
		counter = counter + 1
	}// end if statement 
		target->card_list = target_card_list->next;
	}//end while loop

	// when the counter is 4 go thru hand and remove all 4 
	if (counter == 4){
		while (target->card_list != NULL){
	//checks to see if characters match, since 4 are in list, remove all
               		if (check == R[i]){
				remove_card(&user, &reset->top);
			}// end check
			target->card_list=target->card_list->next;
		}//end while
	target.book[book_size]=R[i];// add that char to the book
	target.book_size=target.book_size+1;// increment to next location
  	}//if counter end

 }//for loop for 12/13 cases


int ten;// seperately checks if the number 10 appears 4 times
while (target->card_list != NULL){
	card_string=target->card_list->top;
				//check if rank==10 case
	char check_ten[2]=card_string->rank[0],card_string->rank[1]

                if (check_ten == "10"){
                        ten = ten + 1;
                                                    }
                target->card_list = target_card_list->next;
                                         }
// if 10 appears 4 times in deck, remove it and add to book
if (ten == 4){
	while (target->card_list != NULL){
          	if (check_ten=="10"){
			//remove head of card_list since 4 are found
               remove_card(&user,&reset->top 							    }
                         target->card_list=target->card_list->next;
                                                            
                                                 }
	target.book[book_size]="10";  // add 10 to the book
	target.book_size=target.book_size+1;// increment book

     
  }//if counter

}//function

*/

/*
 * Function: search
 * ----------------
 *  Search a player's hand for a requested rank.
 *  
 *  rank: the rank to search for
 *  target: the player (and their hand) to search
 *
 *  Return: If the player has a card of that rank, return 1, else return 0
 */
//*************************DONE********************************************
		//search(&computer,rank);
int search(struct player* target,char rank){
//points to the hand 
struct hand *reset=target->card_list;        //set temp pointer to start
//traverse list,
//char rank[2]=rank
// only looks for 1 character
// goes thru the hand and checks the rank of the card with the input rank
// this code is done to turn the rank into a string, so strcmp can be used 
char check[2];
check[0]=rank;
check[1]='\0';
//printf("create string with rank %s\n",check);

bool found=false;
while (reset != NULL){
// rank is a char while top.rank is a string
//	printf("%s\n",reset->top.rank);
		if(strcmp(reset->top.rank,check)==0){	
			found=true;
		}
	reset=reset->next;// iterate thru

}// end while loop

//target->card_list = reset;
if (found==true){
//	printf("Search found");
	return 1;
}
if(found==false){
//	printf("No match found");	
	return 0;}



}// end search


/*
 * Function: transfer_cards
 * ------------------------
 *   Transfer cards of a given rank from the source player's 
 *   hand to the destination player's hand. Remove transferred
 *   cards from the source player's hand. Add transferred cards
 *   to the destination player's hand.
 *   
 *   src: a pointer to the source player
 *   dest: a pointer to the destination player
 *   rank: the rank to transfer
 *
 *   Return: 0 if no cards found/transferred, <0 if error, otherwise 
 *   return value indicates number of cards transferred
 */   

/*
int transfer_cards(struct player* src, struct player* dest, char rank){
// 2 pointers for the players hands
struct hand* recieving_card=dest->card_list;// the destination recieves
struct hand* losing_card=src->card_list;  // the source is giving their card

char check[2];
check[0]=rank;
check[1]='\0';
while (losing_card != NULL){
	if(strcmp(losing_card->rop.rank,check==0){
		remove_card(&src, &dest->card_list->top);		
		add_card(&src, &dest->card_list->top);
 } //if
	losing_card=src->losing_card->next;

} //while


} // end function


*/

/*
 * Function: game_over
 * -------------------
 *   Boolean function to check if a player has 7 books yet
 *   and the game is over
 *
 *   target: the player to check
 *   
 *   Return: 1 if game is over, 0 if game is not over
 */
int game_over(struct player* target);
// if the 7th entry char in book is full, then set the game to over
//bool game_over=false;
//if(target.){
//	bool game_over=true; }
//if (game_over==true){
//	return -1; }
//else{
//	return 0;}


/* 
 * Function: reset_player
 * ----------------------
 *
 *   Reset player by free'ing any memory of cards remaining in hand,
 *   and re-initializes the book.  Used when playing a new game.
 * 
 *   target: player to reset
 * 
 *   Return: 0 if no error, and non-zero on error.
 */

int reset_player(struct player* target);

/* 
 * Function: computer_play
 * -----------------------
 *
 *   Select a rank randomly to play this turn. The player must have at least
 *   one card of the selected rank in their hand.
 *
 *   target: the player's hand to select from
 *
 *   Rank: return a valid selected rank
 */

struct comp_rank
{
	char rank;
};

struct comp_helper
{
	struct comp_rank list[13];
};
struct comp_helper comp;


char computer_play(struct player* target){
// so there are 13 possible ranks to choose from
// create a list of the 13 ranks, shuffle it, and then go down the list and select rank and if it does not exist in the user hand then go to the next rank in the random shuffled list 
//USE THE SHUFFLE CODE TO MAKE A NON SHUFFLED LIST OF RANKS, THEN SHUFFLE IT, THEN SEARCH FIRST ELEMENT WITH SEARCH AND THEN CH

char R[13]={'A','2','3','4','5','6','7','8','9','1','J','Q','K'};
// fill the list
for (int i=0;i<13;i++) {
	comp.list[i].rank=R[i];
//	printf("%c \n",comp.list[i]);
}
// shuffle the list so it chooses rng
int length= sizeof comp.list / sizeof comp.list[0]; // 13
for (int i=0;i<length;i++){
	//srand ( time(NULL) );	// this creates the seed to randomize
	int randomElement=rand()%(1+length-i); //will swap every element once
	struct comp_rank temp;
	temp = comp.list[i];
	comp.list[i] = comp.list[randomElement];
	comp.list[randomElement]=temp;
}
//prints new shuffled order

printf("\n\n the new shuffled order is \n");
for (int i=0;i<13;i++) {
	printf("%c  ",comp.list[i]);
}
printf("\n");
printf("the first card check: %c \n",comp.list[0]);
//char rank=comp.list[0].rank; // set first random rank pick

//printf("the first rank being check by computer is: %c\n",rank);
int i=0;
printDeck(&computer);
printDeck(&user);

char rank=comp.list[i].rank; // goes to next in list if not foun

while(search(&user,comp.list[i].rank)==0){
	printf("Error - must have at least one card from rank to play \n");
	//printf("Player 2's turn, enter a Rank: ");
	i++;//increment
}
printf("the legal rank the comptuer ask for is:%c\n",comp.list[i].rank);// should always be in the deck of the user without fail

 // returns one of ranks->A,2,3.6..Q,K
//printf("legal rank inside user_play is: %c\n",rank);
return comp.list[i].rank; // returns valid selected rank
}
/* 
 * Function: user_play
 * -------------------
 *
 *   Read standard input to get rank user wishes to play.  Must perform error
 *   checking to make sure at least one card in the player's hand is of the 
 *   requested rank.  If not, print out "Error - must have at least one card from rank to play"
 *   and then re-prompt the user.
 *
 *   target: the player's hand to check
 * 
 *   returns: return a valid selected rank
 */   

///***************************DONE********************************
char user_play(struct player* target){

//so scanf will only take the first value, so when 10, check if rank=1 because it sets it as 1  and then concatenate the 0 to end if 1
char rank;
printf("Player 1's turn, enter a Rank: ");
scanf(" %c",&rank);// has to have empty in front of %c and & in front of rank
// keeps on running if it fails, because failing is not an option!
//==0 is the fail case for not finding anything in search function


//if(search(&computer,rank)){printf("matching\n");}
//else{printf("fail\n");}

//search(&computer,rank); // used to check
//use search function to see if the input is legal, if not then print error and try again
while(search(&computer,rank)==0){
	printf("Error - must have at least one card from rank to play \n");
	printf("Player 1's turn, enter a Rank: ");
	scanf(" %c",&rank); //waits for input the space eliminates 2x printing
}

 // returns one of ranks->A,2,3.6..Q,K
//printf("legal rank inside user_play is: %c\n",rank);
return rank; // returns valid selected rank
}


#endif
